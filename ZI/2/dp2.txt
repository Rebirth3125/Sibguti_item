Шифр Шамира:

generate_keypair(p) - Эта функция генерирует ключевую пару для шифра Шамира. Она принимает на вход простое число p, генерирует ещё одно простое число q, и находит целое число a, такое, что a взаимно просто с p-1. Затем вычисляется число b как a^q mod p. Публичный ключ - это тройка (p, q, b), а приватный ключ - это число a.

encrypt(public_key, plaintext) - Эта функция выполняет шифрование текста plaintext с использованием публичного ключа. Генерируется случайное число r, вычисляется c1 как b^r mod p, и каждый символ текста умножается на q^r mod p. Результат представлен в виде пары (c1, c2).

decrypt(ciphertext, private_key, public_key) - Эта функция выполняет расшифровку текста с использованием приватного ключа и публичного ключа. Она вычисляет обратное значение q к a, а затем расшифровывает каждый символ из c2, умножая его на q, а затем беря остаток от деления на p.

Шифр Эль-Гамаля:

generate_keypair() - Эта функция генерирует ключевую пару для шифра Эль-Гамаля. Генерируются случайные простое число q, число alpha из поля Zq*, и приватный ключ private_key. Затем вычисляется beta как alpha^private_key mod q. Публичный ключ - это тройка (q, alpha, beta).

encrypt(public_key, plaintext) - Эта функция выполняет шифрование текста plaintext с использованием публичного ключа. Генерируется случайное число k, вычисляется c1 как alpha^k mod q, и каждый символ текста умножается на beta^k mod q. Результат представлен в виде пары (c1, c2).

decrypt(ciphertext, private_key, public_key) - Эта функция выполняет расшифровку текста с использованием приватного ключа и публичного ключа. Она вычисляет общий секретный ключ s как c1^private_key mod q, а затем расшифровывает каждый символ из c2, умножая его на обратный элемент s в поле Zq.

Шифр Вернама (одноразовый блокнот):

generate_one_time_pad(length) - Эта функция генерирует случайный одноразовый блокнот заданной длины length. Блокнот представлен в виде последовательности случайных байтов.

encrypt(plaintext, one_time_pad) - Эта функция выполняет шифрование текста plaintext с использованием одноразового блокнота one_time_pad. Каждый байт текста XOR-ируется с соответствующим байтом в блокноте. Результат - это шифртекст.

decrypt(ciphertext, one_time_pad) - Эта функция выполняет расшифровку шифртекста с использованием одноразового блокнота one_time_pad. Она применяет операцию XOR к каждому байту шифртекста и блокнота, чтобы восстановить исходный текст.

Шифр RSA:

generate_keypair() - Эта функция генерирует ключевую пару для шифра RSA. Генерируются два больших простых числа p и q, затем вычисляется n = p * q и значение функции Эйлера phi = (p-1)*(q-1). Далее выбирается случайное число e, взаимно простое с phi, и вычисляется приватный ключ d как обратное значение e по модулю phi. Публичный ключ - это пара (n, e), а приватный ключ - это пара (n, d).

encrypt(public_key, plaintext) - Эта функция выполняет шифрование текста plaintext с использованием публичного ключа. Каждый символ текста преобразуется в число, после чего возводится в степень e по модулю n. Результат - это список чисел, представляющих шифртекст.

decrypt(ciphertext, private_key) - Эта функция выполняет расшифровку шифртекста с использованием приватного ключа. Каждое число из шифртекста возводится в степень d по модулю n, а затем преобразуется обратно в символы. Текст восстанавливается из чисел.
************************************************************************************************************
Шифр Шамира:

Генерация ключей: Для начала мы выбираем большое простое число (назовем его p). Затем мы выбираем другое число (q), которое тоже должно быть простым и не равным p. После этого мы выбираем ещё одно число (a), которое должно быть таким, чтобы, если мы поделим его на (p-1), то остаток будет равен 1. Затем мы вычисляем число b, как a возводим в степень q и находим остаток от деления на p. Таким образом, у нас есть публичный ключ (p, q, b) и приватный ключ a.

Шифрование: Если мы хотим зашифровать сообщение, мы выбираем случайное число r. Затем мы вычисляем c1 как b возводим в степень r и находим остаток от деления на p. Затем каждая буква нашего сообщения умножается на q возводимое в степень r и находим остаток от деления на p. Результатом шифрования будет пара чисел (c1, c2).

Расшифровка: Для расшифровки мы используем приватный ключ a. Сначала мы находим число q возводимое в степень, чтобы получить обратное значение a по модулю (p-1). Затем мы берем каждое зашифрованное число из c2 и умножаем его на найденное число q. Затем мы находим остаток от деления на p и получаем исходные буквы сообщения.

Шифр Эль-Гамаля:

Генерация ключей: Сначала выбираем большое простое число q. Затем выбираем случайное число alpha, которое меньше q. Также выбираем приватный ключ private_key. Вычисляем beta как alpha возводим в степень private_key и находим остаток от деления на q. Публичный ключ - это тройка (q, alpha, beta).

Шифрование: Если мы хотим зашифровать сообщение, мы выбираем случайное число k. Затем мы вычисляем c1 как alpha возводим в степень k и находим остаток от деления на q. Затем каждая буква сообщения умножается на beta возводимое в степень k и находим остаток от деления на q. Результат - это пара (c1, c2).

Расшифровка: Для расшифровки мы используем приватный ключ. Сначала находим общий секретный ключ s как c1 возводим в степень private_key и находим остаток от деления на q. Затем берем каждое зашифрованное число из c2, умножаем его на общий секретный ключ s и находим остаток от деления на q. Полученные числа преобразуются обратно в буквы и получается исходное сообщение.

Шифр Вернама (одноразовый блокнот):

Генерация ключей: Одноразовый блокнот - это случайная последовательность чисел (или байтов), такая же длина, как и ваше сообщение.

Шифрование: Для зашифровки сообщения, каждая буква сообщения (или байт) XOR-ится с соответствующим байтом из одноразового блокнота. XOR - это математическая операция, которая получает два байта и выдаёт новый байт. Полученный результат представляет собой шифртекст.

Расшифровка: Для расшифровки шифртекста, нужно просто применить ту же операцию XOR к каждому байту шифртекста и соответствующему байту из одноразового блокнота. Это восстановит исходное сообщение.

Шифр RSA:

Генерация ключей: Выбираются два больших простых числа p и q. Вычисляется n = p * q и phi = (p-1)*(q-1). Затем выбирается открытый ключ e, которое взаимно просто с phi. Приватный ключ d вычисляется как обратное значение e по модулю phi. Публичный ключ - это пара (n, e), а приватный ключ - это пара (n, d).

Шифрование: Чтобы зашифровать сообщение, каждая буква текста преобразуется в число, затем это число возводится в степень e по модулю n. Результат - это список чисел, представляющих шифртекст.

Расшифровка: Для расшифровки шифртекста, каждое число из него возводится в степень d по модулю n. Затем полученные числа преобразуются обратно в буквы и получается исходное сообщение.